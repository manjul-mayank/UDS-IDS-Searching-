# -*- coding: utf-8 -*-
"""UCS_IDS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17wIplVYiuWh1IESKUcB6yqpczrqqB4Ht
"""

from collections import deque

# Define the start and goal state
start_state = [
    [1,3,4],
    [2,'B',5],
    [8,6,7]
]
goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 'B']
]

# Helper function to find the index of the blank ('B') in the puzzle
def find_blank(puzzle):
    for i in range(3):
        for j in range(3):
            if puzzle[i][j] == 'B':
                return i, j

# Helper function to check if a state is the goal state
def is_goal_state(state):
    return state == goal_state

# Helper function to generate possible moves from a given state
def generate_moves(state):
    moves = []
    i, j = find_blank(state)

    # Possible moves: up, down, left, right
    possible_moves = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]

    for move in possible_moves:
        x, y = move
        if 0 <= x < 3 and 0 <= y < 3:
            new_state = [row[:] for row in state]
            new_state[i][j], new_state[x][y] = new_state[x][y], new_state[i][j]
            moves.append(new_state)

    return moves

# Uniform Cost Search (UCS) implementation
def ucs(start_state):
    visited = set()
    queue = deque([(start_state, [])])  # Queue holds the current state and the path

    while queue:
        state, path = queue.popleft()
        visited.add(tuple(map(tuple, state)))  # Convert state to tuple for hashability

        if is_goal_state(state):
            return path, len(path)  # Return both the path and the number of steps

        for move in generate_moves(state):
            if tuple(map(tuple, move)) not in visited:
                queue.append((move, path + [move]))

    return None, 0  # Goal state not found, return 0 steps

# Iterative Deepening Search (IDS) implementation
def ids(start_state, depth_limit):
    depth = 0

    while depth <= depth_limit:
        visited = set()
        stack = [(start_state, [])]  # Stack holds the current state and the path
        steps = 0  # Count of steps

        while stack:
            state, path = stack.pop()
            visited.add(tuple(map(tuple, state)))  # Convert state to tuple for hashability
            steps += 1  # Increment the steps

            if is_goal_state(state):
                return path, steps  # Return path and steps

            if len(path) < depth:
                for move in generate_moves(state):
                    if tuple(map(tuple, move)) not in visited:
                        stack.append((move, path + [move]))

        depth += 1

    return None, steps  # Goal state not found within depth limit, return steps

# main part
print("Starting State:")
for row in start_state:
    print(row)

print("\nGoal State:")
for row in goal_state:
    print(row)


print("\nUsing Uniform Cost Search (UCS):")
ucs_path, ucs_steps = ucs(start_state)
if ucs_path:
    print("Path to Goal State:")
    for state in ucs_path:
        for row in state:
            print(row)
        print()
    print("Steps Taken by UCS:", ucs_steps)
else:
    print("Goal state not reachable using UCS.")

print("\nUsing Iterative Deepening Search (IDS) with depth limit 28:")
depth_limit = 28
ids_path, ids_steps = ids(start_state, depth_limit)
if ids_path:
    print("Path to Goal State:")
    for state in ids_path:
        for row in state:
            print(row)
        print()
    print("Steps taken by IDS:", ids_steps)
else:
    print("Goal state not reachable using IDS within depth limit of", depth_limit)

print(".......Comparision......")
print("No. of Steps taken by UCS:",ucs_steps)
print("No. of Steps taken by IDS with depth limit 28:",ids_steps)